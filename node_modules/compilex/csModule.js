var exec = require('child_process').exec;
var fs = require('fs');
var cuid = require('cuid');
var colors = require('colors');


exports.stats = false;


exports.compileCS = function (envData, code, fn) {
	//creating source file
	var filename = cuid.slug();
	path = './temp/' + filename;


	fs.mkdir(path, 0777, (err) => {
		if (err && exports.stats)
			console.log(err.toString().red);
		else {
			//create temp0 
			fs.writeFile(path + '/temp.cs', code, function (err) {
				if (exports.stats) {
					if (err)
						console.log('ERROR: '.red + err);
					else
						console.log('INFO: '.green + filename + '.cs created');
				}
				if (envData.OS === 'linux') {

					//compile cs code 
					commmand = 'cd temp' + "/" + filename + ' && mcs temp.cs';
					exec(commmand, function (error, stdout, stderr) {
						if (error) {
							if (exports.stats) {
								console.log('INFO: '.green + filename + '.cs contained an error while compiling');
							}
							var out = { error: stderr };
							deleteData(path);
							fn(out);
						}
						else {
							var tempcommand = "cd temp" + "/" + filename + " && mono temp.exe";
							exec(tempcommand, function (error, stdout, stderr) {
								if (error) {

									if (error.toString().indexOf('Error: stdout maxBuffer exceeded.') != -1) {
										var out = { error: 'Error: stdout maxBuffer exceeded. You might have initialized an infinite loop.' };
										deleteData(path);
										fn(out);
									}
									else {
										if (exports.stats) {
											console.log('INFO: '.green + filename + '.cs contained an error while executing');
										}

										var out = { error: stderr };
										deleteData(path);
										fn(out);
									}
								}
								else {
									if (exports.stats) {
										console.log('INFO: '.green + filename + '.cs successfully compiled and executed !');
									}
									var out = { output: stdout };
									deleteData(path);
									fn(out);
								}
							});
						}

					});
				}
			});
		}
	})

	//compiling and exrcuiting source code

} //end of compileCS

deleteData = (path) => {
	command = "rm -r " + path;
	exec(command, function (err) {
		console.log(err);

	});
}


exports.compileCSWithInput = function (envData, code, input, fn) {
	var filename = cuid.slug();
	path = './temp/' + filename;

	//create temp0 
	fs.mkdir(path, 0777, (err) => {
		if (err && exports.stats)
			console.log(err.toString().red);
		else {
			fs.writeFile(path + '/temp.cs', code, function (err) {
				if (exports.stats) {
					if (err)
						console.log('ERROR: '.red + err);
					else
						console.log('INFO: '.green + filename + '.cs created');
				}

				if (envData.OS === 'linux') {

					//compile c code 
					// commmand = 'cd temp && mcs ' + filename + '.cs';
					commmand = 'cd temp'+'/'+filename+' && mcs temp.cs'
					exec(commmand, function (error, stdout, stderr) {
						if (error) {
							if (exports.stats) {
								console.log('INFO: '.green + filename + '.cs contained an error while compiling');
							}
							var out = { error: stderr };
							deleteData(path);
							fn(out);
						}
						else {
							if (input) {
								var inputfile = 'temp.txt';
								
								fs.writeFile(path + "/"+inputfile, input, function (err) {
									if (exports.stats) {
										if (err)
											console.log('ERROR: '.red + err);
										else {
											console.log('INFO: '.green + inputfile + ' (inputfile) created');
var tempcommand = "cd " +path +' && ' + "./" + "temp.exe";									
// var tempcommand = "cd temp && " + "./" + filename + ".exe";

											exec(tempcommand + '<' + inputfile, function (error, stdout, stderr) {
												if (error) {
													if (error.toString().indexOf('Error: stdout maxBuffer exceeded.') != -1) {
														var out = { error: 'Error: stdout maxBuffer exceeded. You might have initialized an infinite loop.' };
														deleteData(path);
														fn(out);
													}
													else {
														if (exports.stats) {
															console.log('INFO: '.green + filename + '.cs contained an error while executing');
														}
														var out = { error: stderr };
														deleteData(path);
														fn(out);
													}
												}
												else {
													if (exports.stats) {
														console.log('INFO: '.green + filename + '.cs successfully compiled and executed !');
													}
													var out = { output: stdout };
													deleteData(path);
													fn(out);
												}
											});

										}

									}
								});

							}
							else //input not provided 
							{
								if (exports.stats) {
									console.log('INFO: '.green + 'Input mission for ' + filename + '.cs');
								}
								var out = { error: 'Input Missing' };
								deleteData(path);
								fn(out);
							}

						}


					});	 //end of csc exec    							
				}



			});
		}
	});
	//end of writeFile


} //end of compileCPPWithInput
